<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Gemini Tic-Tac-Toe</title>
    <!-- Load Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- Load Lucide Icons for aesthetic buttons -->
    <script type="module" src="https://unpkg.com/lucide@latest"></script>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Inter:wght@400;700&display=swap');
        :root {
            --primary-color: #6366f1; /* Indigo 500 */
            --o-color: #fcd34d; /* Amber 300 (Typically 'O') */
            --x-color: #f87171; /* Red 400 (Typically 'X') */
        }
        body {
            font-family: 'Inter', sans-serif;
            background-color: #1f2937; /* Dark Slate Background */
            color: #e5e7eb; /* Light Gray Text */
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            padding: 20px;
        }
        .board-grid {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            grid-template-rows: repeat(3, 1fr);
            gap: 8px;
            width: 100%;
            max-width: 300px;
            aspect-ratio: 1 / 1; /* Ensure perfect square */
            margin: 20px auto;
        }
        .cell {
            background-color: #374151; /* Medium Slate */
            border-radius: 12px;
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 3rem;
            font-weight: bold;
            cursor: pointer;
            transition: background-color 0.2s, transform 0.1s;
            user-select: none;
            box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1), 0 2px 4px -2px rgba(0, 0, 0, 0.06);
        }
        .cell:not(.x-marker):not(.o-marker):hover {
            background-color: #4b5563; /* Lighter Slate on hover */
        }
        .cell.x-marker {
            color: var(--x-color);
        }
        .cell.o-marker {
            color: var(--o-color);
        }
        .cell.winning-cell {
            background-color: var(--primary-color);
            transform: scale(1.05);
            animation: win-glow 0.5s infinite alternate;
        }
        @keyframes win-glow {
            from { box-shadow: 0 0 10px var(--primary-color); }
            to { box-shadow: 0 0 20px var(--primary-color); }
        }
        .message-box {
            min-height: 60px;
            padding: 1rem;
            border-radius: 12px;
            text-align: center;
            font-size: 1.1rem;
            font-weight: 700;
            background-color: #374151;
            box-shadow: 0 10px 15px -3px rgba(0, 0, 0, 0.1), 0 4px 6px -4px rgba(0, 0, 0, 0.1);
        }
    </style>
</head>
<body>

    <div class="w-full max-w-sm bg-gray-800 p-6 rounded-2xl shadow-2xl">
        <h1 class="text-3xl font-bold text-center mb-4 text-white">
            <span class="text-indigo-400">AI</span> Tic-Tac-Toe
        </h1>

        <div id="messageBox" class="message-box mb-4 text-indigo-300">
            Game initializing...
        </div>

        <div class="board-grid" id="boardGrid">
            <!-- Cells will be generated by JS -->
        </div>

        <div class="flex justify-center mt-6">
            <button id="resetButton" class="flex items-center space-x-2 px-6 py-3 bg-indigo-600 hover:bg-indigo-700 text-white font-bold rounded-xl shadow-lg transition duration-150 transform hover:scale-[1.02]">
                <i data-lucide="rotate-ccw" class="w-5 h-5"></i>
                <span>New Game</span>
            </button>
        </div>

        <div id="loadingIndicator" class="mt-4 text-center text-yellow-400 font-semibold hidden">
            <i data-lucide="loader-circle" class="w-5 h-5 inline-block animate-spin mr-2"></i>
            AI is thinking...
        </div>
    </div>

    <script>
        // Ensure Lucide icons are rendered
        lucide.createIcons();

        // --- Game State Variables ---
        let board = Array(9).fill('');
        let gameActive = true;
        let humanPlayer = ''; // Will be randomized
        let aiPlayer = '';    // Will be randomized
        let currentPlayer = 'X'; // X always starts the game
        const modelName = "gemini-2.5-flash-preview-09-2025";
        const apiKey = ""; // Canvas will provide this

        // --- DOM Elements ---
        const boardGrid = document.getElementById('boardGrid');
        const messageBox = document.getElementById('messageBox');
        const resetButton = document.getElementById('resetButton');
        const loadingIndicator = document.getElementById('loadingIndicator');

        // --- Utility Functions ---

        /**
         * Converts the current board array into a readable string for the AI prompt.
         * @returns {string} The board state string.
         */
        const getBoardStatePrompt = () => {
            const boardString = board.map(c => `'${c || ' '}'`).join(', ');
            return `The current 3x3 board state (0-8) is: [${boardString}]. Human is '${humanPlayer}', AI is '${aiPlayer}'. It is '${aiPlayer}'s turn. Determine the single best move. Which index (0-8) should '${aiPlayer}' play?`;
        };

        /**
         * Checks for a winning condition.
         * @param {Array<string>} currentBoard - The board array.
         * @returns {Array<number> | null} Array of winning indices or null.
         */
        const checkWinner = (currentBoard) => {
            const winPatterns = [
                [0, 1, 2], [3, 4, 5], [6, 7, 8], // Rows
                [0, 3, 6], [1, 4, 7], [2, 5, 8], // Columns
                [0, 4, 8], [2, 4, 6]             // Diagonals
            ];

            for (const pattern of winPatterns) {
                const [a, b, c] = pattern;
                if (currentBoard[a] && currentBoard[a] === currentBoard[b] && currentBoard[a] === currentBoard[c]) {
                    return pattern;
                }
            }
            return null;
        };

        /**
         * Gets the Tailwind color class based on the marker.
         * @param {string} marker - 'X' or 'O'.
         * @returns {string} The CSS class for the color.
         */
        const getMarkerColorClass = (marker) => {
            return marker === 'X' ? 'text-red-400' : 'text-yellow-400';
        };

        /**
         * Updates the message box.
         * @param {string} message - The message to display.
         * @param {string} colorClass - Tailwind text color class.
         */
        const updateMessage = (message, colorClass = 'text-indigo-300') => {
            messageBox.className = 'message-box mb-4 font-semibold ' + colorClass;
            messageBox.innerHTML = message;
        };

        /**
         * Draws the board UI based on the current state.
         */
        const renderBoard = () => {
            boardGrid.innerHTML = '';
            board.forEach((cellValue, index) => {
                const cell = document.createElement('div');
                const markerClass = cellValue ? (cellValue === 'X' ? 'x-marker' : 'o-marker') : '';
                cell.className = `cell ${markerClass}`;
                cell.dataset.index = index;
                cell.textContent = cellValue;
                cell.addEventListener('click', () => handleCellClick(index));
                boardGrid.appendChild(cell);
            });
        };

        /**
         * Highlights the winning cells if a winner is found.
         * @param {Array<number>} winningIndices - Indices of the winning line.
         */
        const highlightWin = (winningIndices) => {
            winningIndices.forEach(index => {
                boardGrid.children[index].classList.add('winning-cell');
            });
        };

        /**
         * Core game loop check and turn switch.
         * @returns {boolean} True if the game ended.
         */
        const checkGameStatus = () => {
            const winningIndices = checkWinner(board);
            if (winningIndices) {
                gameActive = false;
                highlightWin(winningIndices);
                const winner = board[winningIndices[0]];
                const winnerTextClass = getMarkerColorClass(winner);
                const winnerRole = winner === humanPlayer ? 'You' : 'AI';
                updateMessage(`${winnerRole} (${winner}) won! üéâ`, winnerRole === 'You' ? 'text-green-400' : 'text-red-400');
                return true;
            }

            if (!board.includes('')) {
                gameActive = false;
                updateMessage(`It's a draw! ü§ù`, 'text-yellow-400');
                return true;
            }
            
            // Switch turn
            currentPlayer = currentPlayer === 'X' ? 'O' : 'X';

            if (gameActive) {
                const marker = currentPlayer;
                const role = marker === humanPlayer ? 'Your' : 'AI';
                updateMessage(`${role} turn (<span class="${getMarkerColorClass(marker)}">${marker}</span>).`, 'text-indigo-300');
            }

            return false;
        };

        // --- AI API Logic ---

        /**
         * Calls the Gemini API to get the AI's move.
         * @returns {Promise<number|null>} The validated index (0-8) or null on failure.
         */
        const callGeminiForMove = async () => {
            const systemPrompt = "You are an expert, unbeatable Tic-Tac-Toe AI. Your task is to analyze the current 3x3 board state and determine the best possible move. Your response must be a single digit (0 to 8) representing the index of the cell where you will place your marker. DO NOT provide any other explanation, text, or reasoning. ONLY return the integer index.";
            const userQuery = getBoardStatePrompt();
            
            const apiUrl = `https://generativelanguage.googleapis.com/v1beta/models/${modelName}:generateContent?key=${apiKey}`;

            const payload = {
                contents: [{ parts: [{ text: userQuery }] }],
                systemInstruction: {
                    parts: [{ text: systemPrompt }]
                },
            };

            const maxRetries = 5;
            let lastError = null;

            for (let attempt = 0; attempt < maxRetries; attempt++) {
                try {
                    const response = await fetch(apiUrl, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify(payload)
                    });

                    if (!response.ok) {
                        const errorBody = await response.json();
                        throw new Error(`API returned status ${response.status}: ${JSON.stringify(errorBody)}`);
                    }

                    const result = await response.json();
                    const candidate = result.candidates?.[0];

                    if (candidate && candidate.content?.parts?.[0]?.text) {
                        const rawText = candidate.content.parts[0].text.trim();
                        // Attempt to extract a single digit (0-8)
                        const moveIndexMatch = rawText.match(/^\s*(\d)\s*$/);

                        if (moveIndexMatch) {
                            const index = parseInt(moveIndexMatch[1], 10);
                            // Validate the move is on the board and the cell is empty
                            if (index >= 0 && index <= 8 && board[index] === '') {
                                return index;
                            } else {
                                lastError = `AI returned invalid or occupied index: ${index} (Raw: ${rawText})`;
                                console.error(lastError);
                            }
                        } else {
                            lastError = `AI response format error (expected single digit 0-8): ${rawText}`;
                            console.error(lastError);
                        }
                    } else {
                        lastError = 'Gemini API response missing content.';
                        console.error(lastError, result);
                    }
                } catch (error) {
                    lastError = error;
                    // Exponential backoff
                    const delay = Math.pow(2, attempt) * 1000;
                    await new Promise(resolve => setTimeout(resolve, delay));
                }
            }

            // Fallback: If AI fails after retries, pick the first available spot.
            console.warn("AI failed to return a valid move after max retries. Using simple fallback.");
            return board.indexOf('');
        };


        /**
         * Handles the AI's turn.
         */
        const makeAIMove = async () => {
            if (!gameActive || currentPlayer !== aiPlayer) return;

            loadingIndicator.classList.remove('hidden');
            
            const aiMoveIndex = await callGeminiForMove();

            loadingIndicator.classList.add('hidden');

            if (aiMoveIndex !== -1 && board[aiMoveIndex] === '') {
                board[aiMoveIndex] = aiPlayer;
                renderBoard();

                checkGameStatus();
            } else {
                // Should only happen if the board is full, but just in case of an error
                gameActive = false;
                updateMessage(`AI error: Could not make a valid move.`, 'text-red-500');
            }
        };

        // --- User Interaction ---

        /**
         * Handles a human player's click on a cell.
         * @param {number} index - The index of the clicked cell.
         */
        const handleCellClick = (index) => {
            if (!gameActive || board[index] !== '' || currentPlayer !== humanPlayer) {
                return;
            }

            // 1. Human makes a move
            board[index] = humanPlayer;
            renderBoard();

            // 2. Check status and switch turn
            if (checkGameStatus()) {
                return;
            }

            // 3. AI's turn
            if (currentPlayer === aiPlayer) {
                makeAIMove();
            }
        };

        // --- Game Setup ---

        /**
         * Resets the game state and UI.
         */
        const resetGame = () => {
            // Randomly assign markers
            const markers = ['X', 'O'];
            if (Math.random() < 0.5) {
                humanPlayer = 'X';
                aiPlayer = 'O';
            } else {
                humanPlayer = 'O';
                aiPlayer = 'X';
            }

            board = Array(9).fill('');
            gameActive = true;
            currentPlayer = 'X'; // X always starts the game
            
            loadingIndicator.classList.add('hidden');
            renderBoard();

            const humanColor = getMarkerColorClass(humanPlayer);
            updateMessage(
                `You are <span class="${humanColor}">${humanPlayer}</span>. ` +
                `${currentPlayer === humanPlayer ? 'It is your turn.' : 'AI goes first.'}`,
                'text-indigo-300'
            );

            // If AI is 'X', it makes the first move
            if (currentPlayer === aiPlayer) {
                makeAIMove();
            }
        };

        // Initialize game on load
        window.onload = () => {
            resetButton.addEventListener('click', resetGame);
            resetGame();
        }
        
    </script>
</body>
</html>

  
